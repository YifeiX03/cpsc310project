import {ValidationResult} from "./ValidationTypes";
import {validateWhere} from "./WhereValidator";
import {validateOptions} from "./OptionsValidator";
import {Dataset} from "./Courses";
import {validateTransformations} from "./TransformationsValidator";
import {extractAggregationColumns, extractDatasetName} from "./DatasetHelper";
// as previous file, may err msgs were generated by copilot, and modified by shibo if the inference is incorrect
// refactoring done by Chat-GPT
// c2 change: this file is refactored by chatgpt


function checkRequestNotNull(request: any): ValidationResult {
	if (request == null) {
		return {valid: false, error: "request is null"};
	}
	return {valid: true};
}

function checkRequiredKeys(request: any): ValidationResult {
	if (!("WHERE" in request) || !("OPTIONS" in request)) {
		return {valid: false, error: "request does not contain WHERE or OPTIONS"};
	}
	return {valid: true};
}

function checkTransformations(request: any): {valid: boolean, transformation: boolean} {
	let transformation = false;
	if (Object.keys(request).length > 2) {
		if (Object.keys(request).length === 3 && ("TRANSFORMATIONS" in request)) {
			transformation = true;
		} else {
			return {valid: false, transformation};
		}
	}
	return {valid: true, transformation};
}

function validateWhereOptionsTypes(request: any): ValidationResult {
	if (typeof request.WHERE !== "object" || typeof request.OPTIONS !== "object") {
		return {valid: false, error: "WHERE or OPTIONS is not an object"};
	}
	return {valid: true};
}

function extractValidateDatasetName(request: any, datasets: Dataset[]): ValidationResult | string {
	let datasetName = extractDatasetName(request);
	if (typeof datasetName !== "string") {
		return datasetName;
	} else if (datasetName === "") {
		return {valid: false, error: "in COLUMN, wrong dataset"};
	}
	return datasetName;
}
// note: this function is generated by Chat-GPT with the prompts from shibo (with code-level detail).
// chatgpt added new validation rules on top of the old function
export function requestValidator(request: any, datasets: Dataset[]): ValidationResult {
	let res = checkRequestNotNull(request);
	if (!res.valid) {
		return res;
	}

	res = checkRequiredKeys(request);
	if (!res.valid) {
		return res;
	}

	const {valid, transformation} = checkTransformations(request);
	if (!valid) {
		return {valid: false, error: "request contains key other than WHERE, OPTIONS, or TRANSFORMATIONS"};
	}

	res = validateWhereOptionsTypes(request);
	if (!res.valid) {
		return res;
	}

	const datasetNameOrValidationResult = extractValidateDatasetName(request, datasets);
	if (typeof datasetNameOrValidationResult !== "string") {
		return datasetNameOrValidationResult;
	}

	const datasetName = datasetNameOrValidationResult;
	res = validateWhere(request.WHERE, datasets, datasetName, true);
	if (!res.valid) {
		return res;
	}

	if (transformation) {
		res = validateTransformations(request.TRANSFORMATIONS, datasetName, datasets);
		if (!res.valid) {
			return res;
		}

		const keys = extractAggregationColumns(request.TRANSFORMATIONS.APPLY);
		if (new Set(keys).size !== keys.length) {
			return {valid: false, error: "Duplicate values found in TRANSFORMATIONS.APPLY keys"};
		}
	}

	return validateOptions(
		request.OPTIONS, datasets,
		transformation ? extractAggregationColumns(request.TRANSFORMATIONS.APPLY) : [],
		transformation, transformation ? request.TRANSFORMATIONS.GROUP : [], datasetName
	);
}


