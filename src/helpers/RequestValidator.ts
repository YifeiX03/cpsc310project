import {ValidationResult} from "./ValidationTypes";
import {validateWhere} from "./WhereValidator";
import {validateOptions} from "./OptionsValidator";
import {Dataset} from "./Courses";
import {validateTransformations} from "./TransformationsValidator";
import {extractAggregationColumns, extractDatasetName} from "./DatasetHelper";
// as previous file, may err msgs were generated by copilot, and modified by shibo if the inference is incorrect

/**
 * Validates a query request
 * @return: ValidationResult
 * @param request
 * @param datasets
 */

/*
export function requestValidator(request: any, datasets: Dataset[]): ValidationResult{
	if (request == null) {
		return {valid: false, error: "request is null"};
	}
	if (!("WHERE" in request) || !("OPTIONS" in request)) {
		return {valid: false, error: "request does not contain WHERE or OPTIONS"}; // err msg generated by copilot
	}
	let transformation = false;
	if (Object.keys(request).length > 2) {
		if (Object.keys(request).length === 3 && ("TRANSFORMATIONS" in request)) {
			transformation = true;
		} else {
			return {valid: false, error: "request contains key other than WHERE or OPTIONS"};
		}
	}
	if (typeof request.WHERE !== "object" || typeof request.OPTIONS !== "object") {
		return {valid: false, error: "WHERE or OPTIONS is not an object"}; // err msg generated by copilot
	}
	let datasetName: string = "";
	let datasetRet = extractDatasetName(request);
	// Check if dataset name is valid, if so, set datasetName for later assertions for only reference one dataset
	if (typeof datasetRet === "string") {
		datasetName = datasetRet;
	} else {
		return datasetRet;
	}
	if (datasetName === "") {
		return {valid: false, error: "in COLUMN, wrong dataset"};
	}
	let res2;
	let res1 = validateWhere(request.WHERE, datasets, datasetName, true);
	if (!res1.valid) {
		return res1;
	}
	if (transformation) {
		res2 = validateTransformations(request.TRANSFORMATIONS, datasetName, datasets);
		if (!res2.valid) {
			return res2;
		}
	}
	if (transformation) {
		let keys = extractAggregationColumns(request.TRANSFORMATIONS.APPLY);
		// Check for duplicate values in keys
		if (new Set(keys).size !== keys.length) {
			return {valid: false, error: "Duplicate values found in TRANSFORMATIONS.APPLY keys"};
		}
	}

	let res3 = validateOptions(request.OPTIONS, datasets,
		transformation ? extractAggregationColumns(request.TRANSFORMATIONS.APPLY) : [], transformation,
		transformation ? request.TRANSFORMATIONS.GROUP : [], datasetName);
	if (!res3.valid) {
		return res3;
	} else {
		return {valid: true};
	}
}

*/

function checkRequestNotNull(request: any): ValidationResult {
	if (request == null) {
		return {valid: false, error: "request is null"};
	}
	return {valid: true};
}
function checkRequiredKeys(request: any): ValidationResult {
	if (!("WHERE" in request) || !("OPTIONS" in request)) {
		return {valid: false, error: "request does not contain WHERE or OPTIONS"};
	}
	return {valid: true};
}

function checkTransformations(request: any): {valid: boolean, transformation: boolean} {
	let transformation = false;
	if (Object.keys(request).length > 2) {
		if (Object.keys(request).length === 3 && ("TRANSFORMATIONS" in request)) {
			transformation = true;
		} else {
			return {valid: false, transformation};
		}
	}
	return {valid: true, transformation};
}

function validateWhereOptionsTypes(request: any): ValidationResult {
	if (typeof request.WHERE !== "object" || typeof request.OPTIONS !== "object") {
		return {valid: false, error: "WHERE or OPTIONS is not an object"};
	}
	return {valid: true};
}

function extractValidateDatasetName(request: any, datasets: Dataset[]): ValidationResult | string {
	let datasetName = extractDatasetName(request);
	if (typeof datasetName !== "string") {
		return datasetName;
	} else if (datasetName === "") {
		return {valid: false, error: "in COLUMN, wrong dataset"};
	}
	return datasetName;
}

export function requestValidator(request: any, datasets: Dataset[]): ValidationResult {
	let res = checkRequestNotNull(request);
	if (!res.valid) {
		return res;
	}

	res = checkRequiredKeys(request);
	if (!res.valid) {
		return res;
	}

	const {valid, transformation} = checkTransformations(request);
	if (!valid) {
		return {valid: false, error: "request contains key other than WHERE, OPTIONS, or TRANSFORMATIONS"};
	}

	res = validateWhereOptionsTypes(request);
	if (!res.valid) {
		return res;
	}

	const datasetNameOrValidationResult = extractValidateDatasetName(request, datasets);
	if (typeof datasetNameOrValidationResult !== "string") {
		return datasetNameOrValidationResult;
	}

	const datasetName = datasetNameOrValidationResult;
	res = validateWhere(request.WHERE, datasets, datasetName, true);
	if (!res.valid) {
		return res;
	}

	if (transformation) {
		res = validateTransformations(request.TRANSFORMATIONS, datasetName, datasets);
		if (!res.valid) {
			return res;
		}

		const keys = extractAggregationColumns(request.TRANSFORMATIONS.APPLY);
		if (new Set(keys).size !== keys.length) {
			return {valid: false, error: "Duplicate values found in TRANSFORMATIONS.APPLY keys"};
		}
	}

	return validateOptions(
		request.OPTIONS, datasets,
		transformation ? extractAggregationColumns(request.TRANSFORMATIONS.APPLY) : [],
		transformation, transformation ? request.TRANSFORMATIONS.GROUP : [], datasetName
	);
}


