import {applyToken, sortSeq, ValidationResult} from "./ValidationTypes";
import {Dataset} from "./Courses";
import {validateKeys} from "./DatasetHelper";
// many err msgs are generated by copilot and fixed by shibo if the err msg inferred from code is incorrect

export function validateOptions(options: object, datasets: Dataset[], newColumns: string[],
	isTrans: boolean, groupColumns: string[], datasetName: string): ValidationResult {
	let loadedDatasets = datasets.map((each) => each.datasetName);
	if (options === null) {
		return {valid: false, error: "OPTIONS is null!"}; // err msg generated by copilot, as stated above
	}
	const validKeys = ["COLUMNS", "ORDER"];  // Valid keys list
	let keys = Object.keys(options);
	if (keys.length === 0) {
		return {valid: false, error: "OPTIONS is empty"}; // err msg generated by copilot
	}
	// the following two statement is coded by chatgpt using a requirement prompt
	// Check for unexpected keys
	const unexpectedKeys = Object.keys(options).filter((key) => !validKeys.includes(key));
	if (unexpectedKeys.length > 0) {
		return {valid: false, error: `Unexpected key(s) in options: ${unexpectedKeys.join(", ")}`};
	}
	// up to here!
	if (!("COLUMNS" in options)) {
		return {valid: false, error: "OPTIONS does not contain COLUMNS"};
	}

	let columns = options.COLUMNS;
	if (!Array.isArray(columns) || !columns.every((col) => typeof col === "string")) {
		return {valid: false, error: "COLUMN is not an array or contains non-string elements"};
	}
	let myres = validateColumns(columns, datasets, newColumns, isTrans, groupColumns, datasetName);
	if (!myres.valid) {
		return myres;
	}

	if ("ORDER" in options) {
		let order = options.ORDER;
		if (typeof order === "string") {
			let res = validateOrderStr(order, options.COLUMNS as string[], datasets, newColumns);
			if (res.valid) {
				if (!(options.COLUMNS as string[]).includes(order)) {
					return {valid: false, error: "ORDER entry is not in COLUMNS"};
				}
			} else {
				return res;
			}
		} else {
			let res2 = validateOrder(order, options.COLUMNS as string[], datasets, newColumns);
			if (!res2.valid) {
				return res2;
			}
		}
	}
	return {valid: true};
}

function validateColumns(columns: string[], datasets: Dataset[], newColumn: string[],
	isTrans: boolean, groupColumns: string[], datasetId: string): ValidationResult {
	let loadedDatasets = datasets.map((each) => each.datasetName);
	if (columns.length === 0) {
		return {valid: false, error: "COLUMNS is empty"};
	}
	// let datasetId = columns[0].split("_")[0];
	if (!loadedDatasets.includes(datasetId)) {
		return {valid: false, error: "COLUMNS contains columns from unloaded dataset"};
	}
	// following generated by chatgpt and modified by shibo
	let columnSet = new Set();
	let newColumnSet = new Set();
	for (let column of columns) {
		let fragment = column.split("_");
		if (fragment.length !== 2) {
			newColumnSet.add(column);
			continue;
		}
		if (fragment[0] !== datasetId) {
			return {valid: false, error: "COLUMNS contains columns from multiple datasets"};
		}
		if (!loadedDatasets.includes(datasetId)) {
			return {valid: false, error: "COLUMNS contains columns from unloaded dataset"};
		}
		columnSet.add(fragment[1]);
	}
	if (columnSet.size + newColumnSet.size !== columns.length) {
		return {valid: false, error: "COLUMNS contains duplicate entries"};
	}
	for (let column of columnSet) {
		if (!validateKeys(datasets, datasetId, column as string, "both")) {
			return {valid: false, error: "COLUMNS contains an unrecognized field"};
		}
		if (isTrans && !groupColumns.includes(datasetId + "_" + column as string)) {
			return {valid: false, error: "invalid column when transformations exists"};
		}
	}
	for (let column of newColumnSet) {
		if (!newColumn.includes(column as string)) {
			return {valid: false, error: "COLUMNS contains a column not found in 'newColumn'"};
		}
	}
	return {valid: true};
	// up to here
}

// note: this function is generated by Chat-GPT with the prompts from shibo (with code-level detail)
function validateOrderStr(order: string, columns: string[], datasets: Dataset[],
	newColumns: string[]): ValidationResult{
	if (newColumns.includes(order)) {
		return {valid: true};
	}
	let loadedDatasets = datasets.map((each) => each.datasetName);
	let targetID = columns[0].split("_")[0];
	if (order.split("_").length !== 2) {
		return {valid: false, error: "ORDER contains no or too many _"};
	}
	let actualID = order.split("_")[0];
	if (targetID !== actualID) {
		return {valid: false, error: "ORDER does not match COLUMNS"};
	}
	if (!loadedDatasets.includes(targetID)) {
		return {valid: false, error: "ORDER references unloaded dataset"};
	}
	let fieldType = order.split("_")[1];
	if (!validateKeys(datasets, targetID, fieldType, "both")) {
		return {valid: false, error: "ORDER contains an unrecognized field"};
	}
	return {valid: true};
}

// note: this function is generated by Chat-GPT with the prompts from shibo (with code-level detail)
function validateOrder(order: any, columns: string[], datasets: Dataset[], newColumns: string[]): ValidationResult {
	if (typeof order !== "object") {
		return {valid: false, error: "Expected 'order' to be an object, but received a different type."};
	}

	const expectedKeys = ["dir", "keys"];
	const orderKeys = Object.keys(order);

	if (orderKeys.length !== 2 || !expectedKeys.every((key) => orderKeys.includes(key))) {
		return {valid: false, error: "The 'order' object must have exactly two keys: 'dir' and 'keys'."};
	}

	if (typeof order.dir !== "string" || !sortSeq.has(order.dir)) {
		return {valid: false, error: "The 'dir' value must be a string and one of the values in 'sortSeq'."};
	}

	if (!Array.isArray(order.keys) || order.keys.length === 0) {
		return {valid: false, error: "The 'keys' value must be a non-empty array."};
	}

	if (!order.keys.every((key: string) => columns.includes(key) || newColumns.includes(key))) {
		return {valid: false, error: "Each key in 'keys' must be present in either 'newColumns' or 'columns'."};
	}

	return {valid: true};
}


